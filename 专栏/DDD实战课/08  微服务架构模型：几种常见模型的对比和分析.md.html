<!DOCTYPE html>

<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

        <link rel="icon" href="/static/favicon.png">

        <title>08  微服务架构模型：几种常见模型的对比和分析.md.html</title>

        <!-- Spectre.css framework -->

        <link rel="stylesheet" href="/static/index.css">

        <!-- theme css & js -->

        <meta name="generator" content="Hexo 4.2.0">

    </head>
<body>
<div class="book-container">

    <div class="book-sidebar">

        <div class="book-brand">

            <a href="/">

                <img src="/static/favicon.png">

                <span>技术文章摘抄</span>

            </a>

        </div>

        <div class="book-menu uncollapsible">

            <ul class="uncollapsible">

                <li><a href="/" class="current-tab">首页</a></li>

            </ul>
            <ul class="uncollapsible">

                <li><a href="../">上一级</a></li>

            </ul>
            <ul class="uncollapsible">

                <li>
                    

                    <a href="/专栏/DDD实战课/00 开篇词  学好了DDD，你能做什么？.md.html">00 开篇词  学好了DDD，你能做什么？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/01 领域驱动设计：微服务设计为什么要选择DDD.md.html">01 领域驱动设计：微服务设计为什么要选择DDD.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/02 领域、子域、核心域、通用域和支撑域：傻傻分不清？.md.html">02 领域、子域、核心域、通用域和支撑域：傻傻分不清？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/03 限界上下文：定义领域边界的利器">03 限界上下文：定义领域边界的利器</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/04 实体和值对象：从领域模型的基础单元看系统设计.md.html">04 实体和值对象：从领域模型的基础单元看系统设计.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/05  聚合和聚合根：怎样设计聚合？.md.html">05  聚合和聚合根：怎样设计聚合？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/06  领域事件：解耦微服务的关键.md.html">06  领域事件：解耦微服务的关键.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/07  DDD分层架构：有效降低层与层之间的依赖.md.html">07  DDD分层架构：有效降低层与层之间的依赖.md.html</a>
                </li>

                <li>
                    <a class="current-tab" href="/专栏/DDD实战课/08  微服务架构模型：几种常见模型的对比和分析.md.html">08  微服务架构模型：几种常见模型的对比和分析.md.html</a>

                    
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/09  中台：数字转型后到底应该共享什么？.md.html">09  中台：数字转型后到底应该共享什么？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/10  DDD、中台和微服务：它们是如何协作的？.md.html">10  DDD、中台和微服务：它们是如何协作的？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/11  DDD实践：如何用DDD重构中台业务模型？.md.html">11  DDD实践：如何用DDD重构中台业务模型？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/12  领域建模：如何用事件风暴构建领域模型？.md.html">12  领域建模：如何用事件风暴构建领域模型？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/13  代码模型（上）：如何使用DDD设计微服务代码模型？.md.html">13  代码模型（上）：如何使用DDD设计微服务代码模型？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/14  代码模型（下）：如何保证领域模型与代码模型的一致性？.md.html">14  代码模型（下）：如何保证领域模型与代码模型的一致性？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/15  边界：微服务的各种边界在架构演进中的作用？.md.html">15  边界：微服务的各种边界在架构演进中的作用？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/16  视图：如何实现服务和数据在微服务各层的协作？.md.html">16  视图：如何实现服务和数据在微服务各层的协作？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/17  从后端到前端：微服务后，前端如何设计？.md.html">17  从后端到前端：微服务后，前端如何设计？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/18  知识点串讲：基于DDD的微服务设计实例.md.html">18  知识点串讲：基于DDD的微服务设计实例.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/19  总结（一）：微服务设计和拆分要坚持哪些原则？.md.html">19  总结（一）：微服务设计和拆分要坚持哪些原则？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/20  总结（二）：分布式架构关键设计10问.md.html">20  总结（二）：分布式架构关键设计10问.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/答疑：有关3个典型问题的讲解.md.html">答疑：有关3个典型问题的讲解.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/DDD实战课/结束语  所谓高手，就是跨过坑和大海.md.html">结束语  所谓高手，就是跨过坑和大海.md.html</a>
                </li>

            </ul>
        </div>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">

        <div class="sidebar-toggle-inner"></div>

    </div>
    <script>

        function add_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.add('show')

        }
        function remove_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.remove('show')

        }
        function sidebar_toggle() {

            let sidebar_toggle = document.querySelector('.sidebar-toggle')

            let sidebar = document.querySelector('.book-sidebar')

            let content = document.querySelector('.off-canvas-content')

            if (sidebar_toggle.classList.contains('extend')) { // show

                sidebar_toggle.classList.remove('extend')

                sidebar.classList.remove('hide')

                content.classList.remove('extend')

            } else { // hide

                sidebar_toggle.classList.add('extend')

                sidebar.classList.add('hide')

                content.classList.add('extend')

            }

        }


function open_sidebar() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.add('show')

    overlay.classList.add('show')

}

function hide_canvas() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.remove('show')

    overlay.classList.remove('show')

}
    </script>
    <div class="off-canvas-content">

        <div class="columns">

            <div class="column col-12 col-lg-12">

                <div class="book-navbar">

                    <!-- For Responsive Layout -->

                    <header class="navbar">

                        <section class="navbar-section">

                            <a onclick="open_sidebar()">

                                <i class="icon icon-menu"></i>

                            </a>

                        </section>

                    </header>

                </div>

                <div class="book-content" style="max-width: 960px; margin: 0 auto;

    overflow-x: auto;

    overflow-y: hidden;">

                    <div class="book-post">

                        <p id="tip" align="center"></p>

                        <div><h1>08  微服务架构模型：几种常见模型的对比和分析</h1>

<p>你好，我是欧创新。</p>

<p>在上一讲中我重点介绍了 DDD 分层架构，同时我也提到了微服务架构模型其实还有好多种，不知道你注意到了没？这些架构模型在我们的实际应用中都具有很高的借鉴价值。</p>

<p>那么今天我们就把 DDD 分层架构（详情介绍如有遗忘可回看 [第 07 讲] ）、整洁架构、六边形架构这三种架构模型放到一起，对比分析，看看如何利用好它们，帮助我们设计出高内聚低耦合的中台以及微服务架构。</p>

<h2>整洁架构</h2>

<p>整洁架构又名“洋葱架构”。为什么叫它洋葱架构？看看下面这张图你就明白了。整洁架构的层就像洋葱片一样，它体现了分层的设计思想。</p>

<p>在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。</p>

<p>整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。</p>

<p><img src="assets/fc8208d9f4cfadb7949d6e98a8c18442.png" alt="img" /></p>

<p>在洋葱架构中，各层的职能是这样划分的：</p>

<p>领域模型实现领域内核心业务逻辑，它封装了企业级的业务规则。领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。</p>

<p>领域服务实现涉及多个实体的复杂业务逻辑。</p>

<p>应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。</p>

<p>最外层主要提供适配的能力，适配能力分为主动适配和被动适配。主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。</p>

<p>红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。</p>

<h2>六边形架构</h2>

<p>六边形架构又名“端口适配器架构”。追溯微服务架构的渊源，一般都会涉及到六边形架构。</p>

<p>六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 API 网关盛行的主要原因吧。</p>

<p>也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 APP、Web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。</p>

<p><img src="assets/85fb9fb2782b343d45b4ca18c8f21e6c.png" alt="img" /></p>

<p>六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：</p>

<p>红圈内的六边形实现应用的核心业务逻辑；</p>

<p>外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 API 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。</p>

<p>六边形架构的一个端口可能对应多个外部系统，不同的外部系统也可能会使用不同的适配器，由适配器负责协议转换。这就使得应用程序能够以一致的方式被用户、程序、自动化测试和批处理脚本使用。</p>

<h2>三种微服务架构模型的对比和分析</h2>

<p>虽然 DDD 分层架构、整洁架构、六边形架构的架构模型表现形式不一样，但你不要被它们的表象所迷惑，这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现，而它们身上闪耀的正是以领域模型为中心的设计思想。</p>

<p><img src="assets/b2e4dad1040857b5aedf0b1675ae4171.png" alt="img" /></p>

<p>我们看下上面这张图，结合图示对这三种架构模型做一个分析。</p>

<p>请你重点关注图中的红色线框，它们是非常重要的分界线，这三种架构里面都有，它的作用就是将核心业务逻辑与外部应用、基础资源进行隔离。</p>

<p>红色框内部主要实现核心业务逻辑，但核心业务逻辑也是有差异的，有的业务逻辑属于领域模型的能力，有的则属于面向用户的用例和流程编排能力。按照这种功能的差异，我们在这三种架构中划分了应用层和领域层，来承担不同的业务逻辑。</p>

<p>领域层实现面向领域模型，实现领域模型的核心业务逻辑，属于原子模型，它需要保持领域模型和业务逻辑的稳定，对外提供稳定的细粒度的领域服务，所以它处于架构的核心位置。</p>

<p>应用层实现面向用户操作相关的用例和流程，对外提供粗粒度的 API 服务。它就像一个齿轮一样进行前台应用和领域层的适配，接收前台需求，随时做出响应和调整，尽量避免将前台需求传导到领域层。应用层作为配速齿轮则位于前台应用和领域层之间。</p>

<p>可以说，这三种架构都考虑了前端需求的变与领域模型的不变。需求变幻无穷，但变化总是有矩可循的，用户体验、操作习惯、市场环境以及管理流程的变化，往往会导致界面逻辑和流程的多变。但总体来说，不管前端如何变化，在企业没有大的变革的情况下，核心领域逻辑基本不会大变，所以领域模型相对稳定，而用例和流程则会随着外部应用需求而随时调整。把握好这个规律，我们就知道该如何设计应用层和领域层了。</p>

<p>架构模型通过分层的方式来控制需求变化从外到里对系统的影响，从外向里受需求影响逐步减小。面向用户的前端可以快速响应外部需求进行调整和发布，灵活多变，应用层通过服务组合和编排来实现业务流程的快速适配上线，减少传导到领域层的需求，使领域层保持长期稳定。</p>

<p>这样设计的好处很明显了，就是可以保证领域层的核心业务逻辑不会因为外部需求和流程的变动而调整，对于建立前台灵活、中台稳固的架构很有帮助。</p>

<p>看到这里，你是不是已经猜出中台和微服务设计的关键了呢？我给出的答案是：领域模型和微服务的合理分层设计。那么你的答案呢？</p>

<h2>从三种架构模型看中台和微服务设计</h2>

<p>结合这三种微服务架构模型的共性，下面我来谈谈中台和微服务设计的一些心得体会。</p>

<p>中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 DDD 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。</p>

<p>中台作为子域还可以继续分解为子子域，在子域分解到合适大小，通过事件风暴划分限界上下文以后，就可以定义微服务了，微服务用来实现中台的能力。表面上看，DDD、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为一个理论体系用于你的中台和微服务设计。</p>

<h3>1. 中台建设要聚焦领域模型</h3>

<p>中台需要站在全企业的高度考虑能力的共享和复用。</p>

<p>中台设计时，我们需要建立中台内所有限界上下文的领域模型，DDD 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。</p>

<p>因此，在中台设计中我们首先要聚焦领域模型，将它放在核心位置。</p>

<h3>2. 微服务要有合理的架构分层</h3>

<p>微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。</p>

<p>不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。如果实在无法避免，我们可以引入防腐层，进行新老系统的适配和转换，过渡期完成后，可以直接将防腐层代码抛弃。</p>

<p>微服务内部的分层方式我们已经清楚了，那微服务之间是否也有层次依赖关系呢？如何实现微服务之间的服务集成？</p>

<p>有的微服务可以与前端应用集成，一起完成特定的业务，这是项目级微服务。而有的则是某个职责单一的中台微服务，企业级的业务流程需要将多个这样的微服务组合起来才能完成，这是企业级中台微服务。两类微服务由于复杂度不一样，集成方式也会有差异。</p>

<p><strong>项目级微服务</strong></p>

<p>项目级微服务的内部遵循分层架构模型就可以了。领域模型的核心逻辑在领域层实现，服务的组合和编排在应用层实现，通过 API 网关为前台应用提供服务，实现前后端分离。但项目级的微服务可能会调用其它微服务，你看在下面这张图中，比如某个项目级微服务 B 调用认证微服务 A，完成登录和权限认证。</p>

<p>通常项目级微服务之间的集成，发生在微服务的应用层，由应用服务调用其它微服务发布在 API 网关上的应用服务。你看下图中微服务 B 中红色框内的应用服务 B，它除了可以组合和编排自己的领域服务外，还可以组合和编排外部微服务的应用服务。它只要将编排后的服务发布到 API 网关供前端调用，这样前端就可以直接访问自己的微服务了。</p>

<p><img src="assets/b4231550cfbd56c15ccb3795d1062f9e.png" alt="img" /></p>

<p><strong>企业级中台微服务</strong></p>

<p>企业级的业务流程往往是多个中台微服务一起协作完成的，那跨中台的微服务如何实现集成呢？</p>

<p>企业级中台微服务的集成不能像项目级微服务一样，在某一个微服务内完成跨微服务的服务组合和编排。</p>

<p>我们可以在中台微服务之上增加一层，你看下面这张图，增加的这一层就位于红色框内，它的主要职能就是处理跨中台微服务的服务组合和编排，以及微服务之间的协调，它还可以完成前端不同渠道应用的适配。如果再将它的业务范围扩大一些，我可以将它做成一个面向不同行业和渠道的服务平台。</p>

<p>我们不妨借用 BFF（服务于前端的后端，Backend for Frontends）这个词，暂且称它为 BFF 微服务。BFF 微服务与其它微服务存在较大的差异，就是它没有领域模型，因此这个微服务内也不会有领域层。BFF 微服务可以承担应用层和用户接口层的主要职能，完成各个中台微服务的服务组合和编排，可以适配不同前端和渠道的要求。</p>

<p><img src="assets/eeb66579c1725817d0e9185161f1843b.png" alt="img" /></p>

<h3>3. 应用和资源的解耦与适配</h3>

<p>传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。</p>

<p>正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。</p>

<p>在微服务架构中，应用层、领域层和基础层解耦是通过仓储模式，采用依赖倒置的设计方法来实现的。在应用设计中，我们会同步考虑和基础资源的代码适配，那么一旦基础设施资源出现变更（比如换数据库），就可以屏蔽资源变更对业务代码的影响，切断业务逻辑对基础资源的依赖，最终降低资源变更对应用的影响。</p>

<h2>总结</h2>

<p>今天我们详细讲解了整洁架构和六边形架构，并对包括 DDD 分层架构在内的三种微服务架构模进行对比分析，总结出了它们的共同特征，并从共性出发，梳理出了中台建模和微服务架构设计的几个要点，我们后面还会有更加详细的有关设计落地的讲述。</p>

<p>**那从今天的内容中我们不难看出：**DDD 分层架构、整洁架构、六边形架构都是以领域模型为核心，实行分层架构，内部核心业务逻辑与外部应用、资源隔离并解耦。请务必记好这个设计思想，今后会有大用处。</p>

</div>

                    </div>

                    <div>

                        <div style="float: left">

                            <a href="/专栏/DDD实战课/07  DDD分层架构：有效降低层与层之间的依赖.md.html">上一页</a>

                        </div>

                        <div style="float: right">

                            <a href="/专栏/DDD实战课/09  中台：数字转型后到底应该共享什么？.md.html">下一页</a>

                        </div>

                    </div>
                </div>

            </div>

        </div>

    </div>
    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

</div>

<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"70996ee81d9b3d60","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>

</body>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script>

    window.dataLayer = window.dataLayer || [];
    function gtag() {

        dataLayer.push(arguments);

    }
    gtag('js', new Date());

    gtag('config', 'G-NPSEEVD756');

    var path = window.location.pathname

    var cookie = getCookie("lastPath");

    console.log(path)

    if (path.replace("/", "") === "") {

        if (cookie.replace("/", "") !== "") {

            console.log(cookie)

            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"

        }

    } else {

        setCookie("lastPath", path)

    }
    function setCookie(cname, cvalue) {

        var d = new Date();

        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));

        var expires = "expires=" + d.toGMTString();

        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";

    }
    function getCookie(cname) {

        var name = cname + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i].trim();

            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);

        }

        return "";

    }
</script>
</html>

