<!DOCTYPE html>

<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

        <link rel="icon" href="/static/favicon.png">

        <title>14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html</title>

        <!-- Spectre.css framework -->

        <link rel="stylesheet" href="/static/index.css">

        <!-- theme css & js -->

        <meta name="generator" content="Hexo 4.2.0">

    </head>
<body>
<div class="book-container">

    <div class="book-sidebar">

        <div class="book-brand">

            <a href="/">

                <img src="/static/favicon.png">

                <span>技术文章摘抄</span>

            </a>

        </div>

        <div class="book-menu uncollapsible">

            <ul class="uncollapsible">

                <li><a href="/" class="current-tab">首页</a></li>

            </ul>
            <ul class="uncollapsible">

                <li><a href="../">上一级</a></li>

            </ul>
            <ul class="uncollapsible">

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/00 数据结构与算法，应该这样学！.md.html">00 数据结构与算法，应该这样学！.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/01  复杂度：如何衡量程序运行的效率？.md.html">01  复杂度：如何衡量程序运行的效率？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html">02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/03  增删查：掌握数据处理的基本操作,以不变应万变.md.html">03  增删查：掌握数据处理的基本操作,以不变应万变.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/04  如何完成线性表结构下的增删查？.md.html">04  如何完成线性表结构下的增删查？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/05  栈：后进先出的线性表，如何实现增删查？.md.html">05  栈：后进先出的线性表，如何实现增删查？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/06  队列：先进先出的线性表，如何实现增删查？.md.html">06  队列：先进先出的线性表，如何实现增删查？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/07  数组：如何实现基于索引的查找？.md.html">07  数组：如何实现基于索引的查找？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html">08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html">09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/10  哈希表：如何利用好高效率查找的“利器”？.md.html">10  哈希表：如何利用好高效率查找的“利器”？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/11  递归：如何利用递归求解汉诺塔问题？.md.html">11  递归：如何利用递归求解汉诺塔问题？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/12  分治：如何利用分治法完成数据查找？.md.html">12  分治：如何利用分治法完成数据查找？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/13  排序：经典排序算法原理解析与优劣对比.md.html">13  排序：经典排序算法原理解析与优劣对比.md.html</a>
                </li>

                <li>
                    <a class="current-tab" href="/专栏/重学数据结构与算法-完/14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html">14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html</a>

                    
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html">15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/16  真题案例（一）：算法思维训练.md.html">16  真题案例（一）：算法思维训练.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/17  真题案例（二）：数据结构训练.md.html">17  真题案例（二）：数据结构训练.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/18  真题案例（三）：力扣真题训练.md.html">18  真题案例（三）：力扣真题训练.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/19  真题案例（四）：大厂真题实战演练.md.html">19  真题案例（四）：大厂真题实战演练.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/20  代码之外，技术面试中你应该具备哪些软素质？.md.html">20  代码之外，技术面试中你应该具备哪些软素质？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/21  面试中如何建立全局观，快速完成优质的手写代码？.md.html">21  面试中如何建立全局观，快速完成优质的手写代码？.md.html</a>
                </li>

                <li>
                    

                    <a href="/专栏/重学数据结构与算法-完/加餐  课后练习题详解.md.html">加餐  课后练习题详解.md.html</a>
                </li>

            </ul>
        </div>

    </div>
    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">

        <div class="sidebar-toggle-inner"></div>

    </div>
    <script>

        function add_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.add('show')

        }
        function remove_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.remove('show')

        }
        function sidebar_toggle() {

            let sidebar_toggle = document.querySelector('.sidebar-toggle')

            let sidebar = document.querySelector('.book-sidebar')

            let content = document.querySelector('.off-canvas-content')

            if (sidebar_toggle.classList.contains('extend')) { // show

                sidebar_toggle.classList.remove('extend')

                sidebar.classList.remove('hide')

                content.classList.remove('extend')

            } else { // hide

                sidebar_toggle.classList.add('extend')

                sidebar.classList.add('hide')

                content.classList.add('extend')

            }

        }


function open_sidebar() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.add('show')

    overlay.classList.add('show')

}

function hide_canvas() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.remove('show')

    overlay.classList.remove('show')

}
    </script>
    <div class="off-canvas-content">

        <div class="columns">

            <div class="column col-12 col-lg-12">

                <div class="book-navbar">

                    <!-- For Responsive Layout -->

                    <header class="navbar">

                        <section class="navbar-section">

                            <a onclick="open_sidebar()">

                                <i class="icon icon-menu"></i>

                            </a>

                        </section>

                    </header>

                </div>

                <div class="book-content" style="max-width: 960px; margin: 0 auto;

    overflow-x: auto;

    overflow-y: hidden;">

                    <div class="book-post">

                        <p id="tip" align="center"></p>

                        <div><h1>14  动态规划：如何通过最优子结构，完成复杂问题求解？</h1>

<p>在前面课时中，我们学习了分治法的思想，并以二分查找为例介绍了分治的实现逻辑。</p>

<p>我们提到过，<strong>分治法的使用必须满足 4 个条件：</strong></p>

<ol>

<li>问题的解决难度与数据规模有关；</li>

<li>原问题可被分解；</li>

<li>子问题的解可以合并为原问题的解；</li>

<li>所有的子问题相互独立。</li>

</ol>

<p>然而在实际工作中还存在这样一类问题，它们满足前 3 个条件，唯独不满足第 4 个条件。那么这类问题我们该怎么解决呢？本课时，我们就来学习求解这类问题的动态规划算法，它是最常用的算法之一。</p>

<h3>什么是动态规划</h3>

<p><strong>从数学的视角来看，动态规划是一种运筹学方法，是在多轮决策过程中的最优方法</strong>。</p>

<p>那么，什么是多轮决策呢？其实多轮决策的每一轮都可以看作是一个子问题。<strong>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一</strong>。</p>

<p>动态规划是候选人参加面试的噩梦，也是面试过程中的难点。虽然动态规划很难，但在实际的工作中，使用频率并不高，不是所有的岗位都会用到动态规划。</p>

<h4>最短路径问题</h4>

<p>接下来。<strong>我们来看一个非常典型的例子，最短路径问题</strong>。如下图所示：</p>

<p><img src="assets/Ciqc1F78bdmAGdktAADnlpYQrHk607.png" alt="image" /></p>

<p>每个结点是一个位置，每条边是两个位置之间的距离。现在需要求解出一条由 A 到 G 的最短距离是多少。</p>

<p>不难发现，我们需要求解的路线是由 A 到 G，这就意味着 A 要先到 B，再到 C，再到 D，再到 E，再到 F。每一轮都需要做不同的决策，而每次的决策又依赖上一轮决策的结果。</p>

<p>例如，做 D2 -&gt; E 的决策时，D2 -&gt; E2 的距离为 1，最短。但这轮的决策，基于的假设是从 D2 出发，这就意味着前面一轮的决策结果是 D2。由此可见，相邻两轮的决策结果并不是独立的。</p>

<p><strong>动态规划还有一个重要概念叫作状态</strong>。在这个例子中，状态是个变量，而且受决策动作的影响。例如，第一轮决策的状态是 S1，可选的值是 A，第二轮决策的状态是 S2，可选的值就是 B1 和 B2。以此类推。</p>

<h3>动态规划的基本方法</h3>

<p>动态规划问题之所以难，是因为动态规划的解题方法并没有那么标准化，它需要你因题而异，仔细分析问题并寻找解决方案。<strong>虽然动态规划问题没有标准化的解题方法，但它有一些宏观层面通用的方法论</strong>：</p>

<blockquote>

<p>下面的 k 表示多轮决策的第 k 轮</p>

</blockquote>

<ol>

<li><strong>分阶段</strong>，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段，它们可以是不满足独立性的。</li>

<li><strong>找状态</strong>，选择合适的状态变量 Sk。它需要具备描述多轮决策过程的演变，更像是决策可能的结果。</li>

<li><strong>做决</strong>策，确定决策变量 uk。每一轮的决策就是每一轮可能的决策动作，例如 D2 的可能的决策动作是 D2 -&gt; E2 和 D2 -&gt; E3。</li>

<li><strong>状态转移方程</strong>。这个步骤是动态规划最重要的核心，<strong>即 sk+1= uk(sk) 。</strong></li>

<li><strong>定目标</strong>。写出代表多轮决策目标的指标函数 Vk,n。</li>

<li><strong>寻找终止条件</strong>。</li>

</ol>

<p>了解了方法论、状态、多轮决策之后，我们再补充一些动态规划的基本概念。</p>

<ul>

<li><strong>策略</strong>，每轮的动作是决策，多轮决策合在一起常常被称为策略。</li>

<li><strong>策略集合</strong>，由于每轮的决策动作都是一个变量，这就导致合在一起的策略也是一个变量。我们通常会称所有可能的策略为策略集合。因此，动态规划的目标，也可以说是从策略集合中，找到最优的那个策略。</li>

</ul>

<p><strong>一般而言，具有如下几个特征的问题，可以采用动态规划求解</strong>：</p>

<ol>

<li><strong>最优子结构</strong>。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>

<li><strong>无后效性</strong>。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>

<li><strong>有重叠子问题</strong>。也就是，子问题之间不独立。<strong>这个性质是动态规划区别于分治法的条件</strong>。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。</li>

</ol>

<h3>动态规划的案例</h3>

<p>到这里，动态规划的概念和方法就讲完了。接下来，我们以最短路径问题再来看看动态规划的求解方法。在这个问题中，你可以采用最暴力的方法，那就是把所有的可能路径都遍历一遍，去看哪个结果的路径最短的。如果采用动态规划方法，那么我们按照方法论来执行。</p>

<h4>动态规划的求解方法</h4>

<p><strong>具体的解题步骤如下</strong>：</p>

<h5>1. <strong>分阶段</strong></h5>

<p>很显然，从 A 到 G，可以拆分为 A -&gt; B、B -&gt; C、C -&gt; D、D -&gt; E、E -&gt; F、F -&gt; G，6 个阶段。</p>

<h5>2. <strong>找状态</strong></h5>

<p>第一轮的状态 S1 = A，第二轮 S2 = {B1,B2}，第三轮 S3 = {C1,C2,C3,C4}，第四轮 S4 = {D1,D2,D3}，第五轮 S5 = {E1,E2,E3}，第六轮 S6 = {F1,F2}，第七轮 S7 = {G}。</p>

<h5>3. <strong>做决策</strong></h5>

<p>决策变量就是上面图中的每条边。我们以第四轮决策 D -&gt; E 为例来看，可以得到 u4(D1)，u4(D2)，u4(D3)。其中 u4(D1) 的可能结果是 E1 和 E2。</p>

<h5>4. <strong>写出状态转移方程</strong></h5>

<p>在这里，就是 <em>s**k</em>+1 = <em>u**k</em>(<em>s**k</em>)。</p>

<h5>5. <strong>定目标</strong></h5>

<p>别忘了，我们的目标是总距离最短。我们定义 <em>d**k</em>(<em>s**k</em>,<em>u**k</em>) 是在 sk 时，选择 uk 动作的距离。例如，<em>d</em>5(<em>E</em>1,<em>F</em>1) = 3。那么此时 n = 7，则有，</p>

<p><img src="assets/CgqCHl78bqSAQBWuAAAmIGYXrUs078.png" alt="image" /></p>

<p>就是最终要优化的目标。</p>

<h5>6. <strong>寻找终止条件</strong></h5>

<ul>

<li>很显然，这里的起止条件分别是，s1 = A 和 s7 = G。</li>

<li>接下来，我们把所有的已知条件，凝练为上面的符号之后，只需要借助最优子结构，就可以把问题解决了。最优子结构的含义是，原问题的最优解所包括的子问题的解也是最优的。</li>

<li>套用在这个例子的含义就是，如果 A -&gt; ... -&gt; F1 -&gt; G 是全局 A 到 G 最优的路径，那么此处 A -&gt; ... -&gt; F1 也是 A 到 F1 的最优路径。</li>

<li>因此，此时的优化目标 min Vk,7(s1=A, s7=G)，等价于 min { Vk,6(s1=A, s6=F1)+4， Vk,6(s1=A, s6=F2)+3 }。</li>

<li>此时，优化目标的含义为，从 A 到 G 的最短路径，是 A 到 F1 到 G 的路径和 A 到 F2 到 G 的路径中更短的那个。</li>

<li>同样的，对于上面式子中，Vk,6(s1=A,s6=F1) 和 Vk,6(s1=A,s6=F2)，仍然可以递归地使用上面的分析方法。</li>

</ul>

<h4>计算过程详解</h4>

<p>好了，为了让大家清晰地看到结果，我们给出详细的计算过程。为了书写简单，<strong>我们把函数 Vk,7(s1=A, s7=G) 精简为 V7(G)，含义为经过了 6 轮决策后，状态到达 G 后所使用的距离</strong>。我们把图片复制到这里一份，方便大家不用上下切换。</p>

<p><img src="assets/CgqCHl78bpKAF2FWAADnlpYQrHk836.png" alt="image" /></p>

<p><strong>我们的优化目标为 min Vk,7(s1=A, s7=G)，因此精简后原问题为，min V7(G)</strong>。</p>

<p><img src="assets/Ciqc1F78bvCAD2QkAABAo0Sezlc723.png" alt="image" /></p>

<p><img src="assets/Ciqc1F79TfyAEbKKAAB2PY0Lb5U909.png" alt="5.png" /></p>

<p><img src="assets/Ciqc1F78bx2AO3WTAACB1LuxHEo059.png" alt="imag" /></p>

<p><img src="assets/Ciqc1F78bySAdLa-AACOk2cGokg643.png" alt="iage" /></p>

<p><img src="assets/CgqCHl79TgmAfHtMAACROQbL6JE078.png" alt="2.png" /></p>

<p><img src="assets/CgqCHl78bzKAQTrCAABoEJ4y5UM123.png" alt="imag" /></p>

<p>因此，<strong>最终输出路径为 A -&gt; B1 -&gt; C2 -&gt; D1 -&gt; E2 -&gt; F2 -&gt; G，最短距离为 18</strong>。</p>

<h4>代码实现过程</h4>

<p>接下来，我们尝试用代码来实现上面的计算过程。对于输入的图，可以采用一个 m x m 的二维数组来保存。在这个二维数组里，m 等于全部的结点数，也就是结点与结点的关系图。而数组每个元素的数值，定义为结点到结点需要的距离。</p>

<p><img src="assets/Ciqc1F78bz2ATtl4AADnlpYQrHk384.png" alt="imae" /></p>

<p>在本例中，可以定义输入矩阵 m（空白处为0），如下图所示：</p>

<p><img src="assets/CgqCHl78b0mALhRHAABQnqgjMYc406.png" alt="imae" /></p>

<p>代码如下：</p>

<pre><code>public class testpath {

    public static int minPath1(int[][] matrix) {

        return process1(matrix, matrix[0].length-1);

    }

    // 递归

    public static int process1(int[][] matrix, int i) {

        // 到达A退出递归

        if (i == 0) {

            return 0;

        }

        // 状态转移

        else{

            int distance = 999;

            for(int j=0; j&lt;i; j++){

                if(matrix[j][i]!=0){

                    int d_tmp = matrix[j][i] + process1(matrix, j);

                    if (d_tmp &lt; distance){

                        distance = d_tmp;

                    }

                }

            }

            return distance;

        }

    }

    public static void main(String[] args) {

        int[][] m = {{0,5,3,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,3,6,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,8,7,6,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,6,8,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,3,5,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,8,4,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,3,5,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3}};

        System.out.println(minPath1(m));

    }

}

</code></pre>

<h4>代码解读</h4>

<p><strong>下面我们对这段代码进行解读</strong>：</p>

<p><strong>代码的 27 行是主函数</strong>，在代码中定义了二维数组 m，对应于输入的距离图。m 是 15 x 16 维的，我们忽略了最后一行的全 0（即使输入也不会影响结果）。</p>

<p><strong>然后调用函数 minPath1</strong>。<strong>在第 2 到第 4 行</strong>，它的内部又调用了 process1(matrix, matrix[0].length-1)。在这里，matrix[0].length-1 的值是 15，表示的含义是 matrix 数组的第 16 列（G）是目的地。</p>

<p><strong>接着进入 process1 函数中</strong>。我们知道在动态规划的过程中，是从后往前不断地推进结果，这就是状态转移的过程。<strong>对应代码中的 13-24 行：</strong></p>

<ul>

<li>第 15 行开始循环，j 变量是纵向的循环变量。</li>

<li>第 16 行判断 matrix[j][i] 与 0 的关系，含义为，只有值不为 0 才说明两个结点之间存在通路。</li>

<li>一旦发现某个通路，就需要计算其距离。计算的方式是 17 行的，d_tmp = matrix[j][i] + process1(matrix, j)。</li>

<li>当得到了距离之后，还需要找到最短的那个距离，也就是 18 到 20 行的含义。这就是动态规划最优子结构的体现。</li>

<li>一旦 i 减小到了 0，就说明已经到了起点 A。那么 A 到 A 的距离就是 0，直接第 10 行的 return 0 就可以了。</li>

<li>经过运行，这段代码的输出结果是 18，这与我们手动的推导结果一致。</li>

</ul>

<h3>练习题</h3>

<p>在 08 课时中，我们讲述“字符串匹配算法的案例”时提到过，最大公共子串也可以使用动态规划的方法来做。</p>

<p>案例题目如下：</p>

<p>假设有且仅有 1 个最大公共子串。比如，输入 a = &quot;13452439&quot;， b = &quot;123456&quot;。由于字符串 &quot;345&quot; 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 &quot;345&quot;。</p>

<p>我们就把这个问题当作本课时的练习题。详细分析和答案，请翻阅 16 课时例题 3。</p>

<h3>总结</h3>

<p>动态规划领域有很多经典问题，本课时，我们讲述了最短路径的问题。需要明确的是，动态规划并不简单，动态规划的适用范围也没有那么广。如果你不是专门从事运筹优化领域的工作，对它不了解也很正常。如果在求职过程中，你求职的岗位与运筹优化关系不大，一般而言被考察到动态规划的可能性也是极低的。</p>

</div>

                    </div>

                    <div>

                        <div style="float: left">

                            <a href="/专栏/重学数据结构与算法-完/13  排序：经典排序算法原理解析与优劣对比.md.html">上一页</a>

                        </div>

                        <div style="float: right">

                            <a href="/专栏/重学数据结构与算法-完/15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html">下一页</a>

                        </div>

                    </div>
                </div>

            </div>

        </div>

    </div>
    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

</div>

<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"70997ddbee193cfa","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>

</body>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script>

    window.dataLayer = window.dataLayer || [];
    function gtag() {

        dataLayer.push(arguments);

    }
    gtag('js', new Date());

    gtag('config', 'G-NPSEEVD756');

    var path = window.location.pathname

    var cookie = getCookie("lastPath");

    console.log(path)

    if (path.replace("/", "") === "") {

        if (cookie.replace("/", "") !== "") {

            console.log(cookie)

            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"

        }

    } else {

        setCookie("lastPath", path)

    }
    function setCookie(cname, cvalue) {

        var d = new Date();

        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));

        var expires = "expires=" + d.toGMTString();

        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";

    }
    function getCookie(cname) {

        var name = cname + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i].trim();

            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);

        }

        return "";

    }
</script>
</html>

