<!DOCTYPE html>

<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

        <link rel="icon" href="/static/favicon.png">

        <title>01 开篇词：从中间件开始学习分布式.md.html</title>

        <!-- Spectre.css framework -->

        <link rel="stylesheet" href="/static/index.css">

        <!-- theme css & js -->

        <meta name="generator" content="Hexo 4.2.0">

    </head>



<body>



<div class="book-container">

    <div class="book-sidebar">

        <div class="book-brand">

            <a href="/">

                <img src="/static/favicon.png">

                <span>技术文章摘抄</span>

            </a>

        </div>

        <div class="book-menu uncollapsible">

            <ul class="uncollapsible">

                <li><a href="/" class="current-tab">首页</a></li>

            </ul>



            <ul class="uncollapsible">

                <li><a href="../">上一级</a></li>

            </ul>



            <ul class="uncollapsible">

                <li>



                    <a class="current-tab" href="/专栏/分布式中间件实践之路（完）/01 开篇词：从中间件开始学习分布式.md.html">01 开篇词：从中间件开始学习分布式.md.html</a>

                    



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/02 走进分布式中间件（课前必读）.md.html">02 走进分布式中间件（课前必读）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/03 主流分布式缓存方案的解读及比较.md.html">03 主流分布式缓存方案的解读及比较.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/04 分布式一致性协议 Gossip 和 Redis 集群原理解析.md.html">04 分布式一致性协议 Gossip 和 Redis 集群原理解析.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/05 基于 Redis 的分布式缓存实现及加固策略.md.html">05 基于 Redis 的分布式缓存实现及加固策略.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/06 Redis 实际应用中的异常场景及其根因分析和解决方案.md.html">06 Redis 实际应用中的异常场景及其根因分析和解决方案.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/07 Redis-Cluster 故障倒换调优原理分析.md.html">07 Redis-Cluster 故障倒换调优原理分析.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/08 基于 Redis 的分布式锁实现及其踩坑案例.md.html">08 基于 Redis 的分布式锁实现及其踩坑案例.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/09 分布式一致性算法 Raft 和 Etcd 原理解析.md.html">09 分布式一致性算法 Raft 和 Etcd 原理解析.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/10 基于 Etcd 的分布式锁实现原理及方案.md.html">10 基于 Etcd 的分布式锁实现原理及方案.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/11 主流的分布式消息队列方案解读及比较.md.html">11 主流的分布式消息队列方案解读及比较.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/12 搭建基于 Kafka 和 ZooKeeper 的分布式消息队列.md.html">12 搭建基于 Kafka 和 ZooKeeper 的分布式消息队列.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/13 深入解读基于 Kafka 和 ZooKeeper 的分布式消息队列原理.md.html">13 深入解读基于 Kafka 和 ZooKeeper 的分布式消息队列原理.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/分布式中间件实践之路（完）/14 深入浅出解读 Kafka 的可靠性机制.md.html">14 深入浅出解读 Kafka 的可靠性机制.md.html</a>



                </li>

            </ul>



        </div>

    </div>



    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">

        <div class="sidebar-toggle-inner"></div>

    </div>



    <script>

        function add_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.add('show')

        }



        function remove_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.remove('show')

        }



        function sidebar_toggle() {

            let sidebar_toggle = document.querySelector('.sidebar-toggle')

            let sidebar = document.querySelector('.book-sidebar')

            let content = document.querySelector('.off-canvas-content')

            if (sidebar_toggle.classList.contains('extend')) { // show

                sidebar_toggle.classList.remove('extend')

                sidebar.classList.remove('hide')

                content.classList.remove('extend')

            } else { // hide

                sidebar_toggle.classList.add('extend')

                sidebar.classList.add('hide')

                content.classList.add('extend')

            }

        }





function open_sidebar() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.add('show')

    overlay.classList.add('show')

}

function hide_canvas() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.remove('show')

    overlay.classList.remove('show')

}



    </script>



    <div class="off-canvas-content">

        <div class="columns">

            <div class="column col-12 col-lg-12">

                <div class="book-navbar">

                    <!-- For Responsive Layout -->

                    <header class="navbar">

                        <section class="navbar-section">

                            <a onclick="open_sidebar()">

                                <i class="icon icon-menu"></i>

                            </a>

                        </section>

                    </header>

                </div>

                <div class="book-content" style="max-width: 960px; margin: 0 auto;

    overflow-x: auto;

    overflow-y: hidden;">

                    <div class="book-post">

                        <p id="tip" align="center"></p>

                        <div><h1>01 开篇词：从中间件开始学习分布式</h1>

<h3>专栏背景</h3>

<p>谈及“分布式系统”，初学者的第一感觉多半是“高大上”和“深不可测”，犹如武林绝学——飞鸟投林、踏浪行波，行走江湖，即便没有见过，也应听过其名。</p>

<p>盛名之下无虚士，分布式系统凭借其高吞吐、高并发、低延迟和负载均衡的特点，迎合了互联网飞速发展背后的巨大承载量需求，民间和官方都有忠实粉丝为其著书立说，然而，大多倾向于理论，对于初学者有一定难度。鉴于此，我期望通过本专栏中的系列文章，用理论与实践结合的方式阐明分布式系统的原理、优势及面临的挑战，进而指导实践。</p>

<p>那么，如何将理论与实践结合呢？切入点的选取是关键，几经考量，我选择了一个最具“通用性”的角度——中间件（Middleware）。如果你不清楚什么是中间件，那你也应该听说过 Redis、Kafka、ZooKeeper、Etcd、RabbitMQ、Nginx 之一，它们都是常用的中间件，可实现缓存、消息队列、锁以及负载均衡等。中间件是基础软件的一大类，属于可复用软件的范畴，顾名思义，中间件处于操作系统软件与用户的应用软件的中间，因此，中间件具有很好的独立性，可作为一个独立的软件系统运转。</p>

<p>随着互联网的飞速发展，高吞吐、高并发、低延迟和负载均衡已成为普遍需求，为此，作为枢纽的中间件也从“集中式”发展为“分布式”——如基于 Redis 的分布式缓存、基于 Kafka 的分布式消息队列、基于 ZooKeeper 的分布式锁等等。青山遮不住，毕竟东流去，随着“云时代”的到来，作为通用软件的中间件再次华丽转身，阿里云、腾讯云、华为云都竞相推出了“云中间件服务”——如 TencentDB for Redis、消息队列 CMQ、云数据库 Redis 等等，几乎应有尽有。</p>

<p>从另一角度来看，作为一名 IT 行业的研发人员，从普通研发工程师到架构师的成长之路上，分布式中间件是绕不过去的。青丝弹指雪，刹那芳华，如果可以，何不从现在开始学习？</p>

<h3>专栏框架</h3>

<p>本专栏从分布式系统切入，首先介绍了集中式系统到分布式系统的演进，并对分布式系统的特性和常见问题进行了阐述。而后进入正题，依次介绍了三大分布式中间件：分布式缓存、分布式锁以及分布式消息队列。</p>

<p>本专栏分为四部分：</p>

<p>第一部分（第01课）：基础篇。</p>

<p>优秀的理论可以指导实践，为了使读者更好的理解分布式系统和中间件，本部分内容以简练的笔触介绍了集中式系统到分布式系统的演进，并对分布式系统的特性和相关理论进行了阐述。最后，从应用场景出发，引出了三大分布式中间件。</p>

<p>第二部分（第02-06课）：分布式缓存。</p>

<p>分布式缓存是应用范围最为广泛的中间件之一，因此最先介绍它。本部分内容首先对当前主流的分布式缓存方案进行了解读；随后浓墨重彩的阐述了 Redis-Cluster 的集群原理和基于 Redis 的分布式缓存实现，并列举了实际应用中 Redis 的典型异常、根因分析及解决方案；最后，结合源码分析了 Redis-Cluster 主节点故障场景下的调优策略。</p>

<p>第三部分（第07-10课）：分布式锁。</p>

<p>在分布式系统中，为保障不同进程争夺共享资源的安全性，需要分布式锁协助。实现分布式锁的方案很多，本部分内容首先对比分析当前主流的分布式锁方案，之后详细解读了基于 Redis 的分布式锁实现和基于 Etcd 的分布式锁实现；特别是 Etcd，作为后起之秀，在很多方面优于 ZooKeeper，但目前在网上几乎找不到完整的方案，鉴于此，本部分对其进行了详细解读。</p>

<p>第四部分（第11-13课）：分布式消息队列。</p>

<p>消息队列是分布式应用间交换信息的重要组件，可以解决应用解耦、异步消息、流量削锋等问题，是实现高性能、高可用、可伸缩和最终一致性架构中不可或缺的一环。本部分内容首先对当前主流的分布式消息队列方案进行了解读，之后深入浅出的阐述了基于 Kafka 的分布式消息队列实现和基于 RocketMQ 的分布式消息队列实现。</p>

<h3>选择本专栏的理由</h3>

<p>如果你正在看这段内容，我相信你对本专栏是感兴趣的，虽然我很期待你选择本专栏，但坦诚地讲，并没有十分具有说服力的理由，选择与否，主要还在于你对 “效率” 这个词的理解。只要你有足够的耐心和时间，本专栏中的部分知识在网上也能找到，当然，我并不推荐这种方式。对于分布式系统、中间件这类需要系统性学习的知识，网络搜索不仅费时费力，而且可信度存疑。</p>

<h4>来自实践，服务实践</h4>

<p>本专栏是我从事中间件研发的经验总结，来自实践，服务于实践。专栏主要包括分布式缓存、分布式锁、分布式消息队列三大部分内容，涉及 Redis、Etcd、Kafka、RocketMQ 等众多主流开源软件的使用方案。不仅提供关键源代码供读者快速实践，而且阐明其中原理并给出踩坑案例和调优分析，致力于授读者以渔。</p>

<h4>理论加持，事半功倍</h4>

<p>在 “多、快、好、省，跑步前进……”的“实用主义”熏陶下，理论二字，很多时候是令人反感的，似乎成了虚无、不切实际、缺乏实践意义的代名词。但凡事不可一概而论，事实证明，成功的实践背后常常有优秀的理论指导。</p>

<p>以 Redis 为例，官方推出的 Redis Cluster 号称最大可支持1000个实例的集群，为什么不可以再多一点，比如2000个呢？又或者这样问：为什么 BAT 都没有采用 Redis Cluster？如果读者知道 Redis Cluster 所采用的分布式一致性协议及其原理，那么一定不难回答上面的问题。</p>

<p>在实践中，理论加持常常可以达到事半功倍的效果，因此，本专栏并不局限于方案的简单实现，而是在介绍方案的同时，对其背后的原理进行了深入浅出的论述。</p>

<h4>方案对比，注重迁移</h4>

<p>没有一种方案可以打遍全场，在中间件选型和方案设计的时候，需结合性能需求、开发成本、可扩展性、可维护性等进行综合评估。例如：基于 ZooKeeper 实现分布式锁的方案非常成熟，参考资料详实，但它并不一定适合你的应用场景，何不考虑一下 Etcd？等等，你是不是根本没有听说过 Etcd？</p>

<p>本专栏介绍了三大中间件：缓存、锁、消息队列，并对每一种中间件的主流实现方案进行了对比分析，以便读者举一反三，迁移应用。</p>

</div>

                    </div>

                    <div>

                        

                        <div style="float: right">

                            <a href="/专栏/分布式中间件实践之路（完）/02 走进分布式中间件（课前必读）.md.html">下一页</a>

                        </div>

                    </div>



                </div>

            </div>

        </div>

    </div>



    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

</div>

<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"70997669ad233cfa","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>

</body>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script>

    window.dataLayer = window.dataLayer || [];



    function gtag() {

        dataLayer.push(arguments);

    }



    gtag('js', new Date());

    gtag('config', 'G-NPSEEVD756');

    var path = window.location.pathname

    var cookie = getCookie("lastPath");

    console.log(path)

    if (path.replace("/", "") === "") {

        if (cookie.replace("/", "") !== "") {

            console.log(cookie)

            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"

        }

    } else {

        setCookie("lastPath", path)

    }



    function setCookie(cname, cvalue) {

        var d = new Date();

        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));

        var expires = "expires=" + d.toGMTString();

        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";

    }



    function getCookie(cname) {

        var name = cname + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i].trim();

            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);

        }

        return "";

    }



</script>



</html>

