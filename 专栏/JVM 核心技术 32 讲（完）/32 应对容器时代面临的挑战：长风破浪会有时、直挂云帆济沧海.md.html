<!DOCTYPE html>

<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

        <link rel="icon" href="/static/favicon.png">

        <title>32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md.html</title>

        <!-- Spectre.css framework -->

        <link rel="stylesheet" href="/static/index.css">

        <!-- theme css & js -->

        <meta name="generator" content="Hexo 4.2.0">

    </head>



<body>



<div class="book-container">

    <div class="book-sidebar">

        <div class="book-brand">

            <a href="/">

                <img src="/static/favicon.png">

                <span>技术文章摘抄</span>

            </a>

        </div>

        <div class="book-menu uncollapsible">

            <ul class="uncollapsible">

                <li><a href="/" class="current-tab">首页</a></li>

            </ul>



            <ul class="uncollapsible">

                <li><a href="../">上一级</a></li>

            </ul>



            <ul class="uncollapsible">

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/01 阅读此专栏的正确姿势.md.html">01 阅读此专栏的正确姿势.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/02 环境准备：千里之行，始于足下.md.html">02 环境准备：千里之行，始于足下.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/03 常用性能指标：没有量化，就没有改进.md.html">03 常用性能指标：没有量化，就没有改进.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/04 JVM 基础知识：不积跬步，无以至千里.md.html">04 JVM 基础知识：不积跬步，无以至千里.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/05 Java 字节码技术：不积细流，无以成江河.md.html">05 Java 字节码技术：不积细流，无以成江河.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/06 Java 类加载器：山不辞土，故能成其高.md.html">06 Java 类加载器：山不辞土，故能成其高.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/07 Java 内存模型：海不辞水，故能成其深.md.html">07 Java 内存模型：海不辞水，故能成其深.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/08 JVM 启动参数详解：博观而约取、厚积而薄发.md.html">08 JVM 启动参数详解：博观而约取、厚积而薄发.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/09 JDK 内置命令行工具：工欲善其事，必先利其器.md.html">09 JDK 内置命令行工具：工欲善其事，必先利其器.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/10 JDK 内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md.html">10 JDK 内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/11 JDWP 简介：十步杀一人，千里不留行.md.html">11 JDWP 简介：十步杀一人，千里不留行.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/12 JMX 与相关工具：山高月小，水落石出.md.html">12 JMX 与相关工具：山高月小，水落石出.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/13 常见的 GC 算法（GC 的背景与原理）.md.html">13 常见的 GC 算法（GC 的背景与原理）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/14 常见的 GC 算法（ParallelCMSG1）.md.html">14 常见的 GC 算法（ParallelCMSG1）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/15 Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新.md.html">15 Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/16 Oracle GraalVM 介绍：会当凌绝顶、一览众山小.md.html">16 Oracle GraalVM 介绍：会当凌绝顶、一览众山小.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/17 GC 日志解读与分析（基础配置）.md.html">17 GC 日志解读与分析（基础配置）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/18 GC 日志解读与分析（实例分析上篇）.md.html">18 GC 日志解读与分析（实例分析上篇）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/19 GC 日志解读与分析（实例分析中篇）.md.html">19 GC 日志解读与分析（实例分析中篇）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/20 GC 日志解读与分析（实例分析下篇）.md.html">20 GC 日志解读与分析（实例分析下篇）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/21 GC 日志解读与分析（番外篇可视化工具）.md.html">21 GC 日志解读与分析（番外篇可视化工具）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/22 JVM 的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md.html">22 JVM 的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/23 内存分析与相关工具上篇（内存布局与分析工具）.md.html">23 内存分析与相关工具上篇（内存布局与分析工具）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/24 内存分析与相关工具下篇（常见问题分析）.md.html">24 内存分析与相关工具下篇（常见问题分析）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md.html">25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/26 面临复杂问题时的几个高级工具：它山之石，可以攻玉.md.html">26 面临复杂问题时的几个高级工具：它山之石，可以攻玉.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/27 JVM 问题排查分析上篇（调优经验）.md.html">27 JVM 问题排查分析上篇（调优经验）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/28 JVM 问题排查分析下篇（案例实战）.md.html">28 JVM 问题排查分析下篇（案例实战）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/29 GC 疑难情况问题排查与分析（上篇）.md.html">29 GC 疑难情况问题排查与分析（上篇）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/30 GC 疑难情况问题排查与分析（下篇）.md.html">30 GC 疑难情况问题排查与分析（下篇）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/JVM 核心技术 32 讲（完）/31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md.html">31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md.html</a>



                </li>

                <li>



                    <a class="current-tab" href="/专栏/JVM 核心技术 32 讲（完）/32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md.html">32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md.html</a>

                    



                </li>

            </ul>



        </div>

    </div>



    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">

        <div class="sidebar-toggle-inner"></div>

    </div>



    <script>

        function add_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.add('show')

        }



        function remove_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.remove('show')

        }



        function sidebar_toggle() {

            let sidebar_toggle = document.querySelector('.sidebar-toggle')

            let sidebar = document.querySelector('.book-sidebar')

            let content = document.querySelector('.off-canvas-content')

            if (sidebar_toggle.classList.contains('extend')) { // show

                sidebar_toggle.classList.remove('extend')

                sidebar.classList.remove('hide')

                content.classList.remove('extend')

            } else { // hide

                sidebar_toggle.classList.add('extend')

                sidebar.classList.add('hide')

                content.classList.add('extend')

            }

        }





function open_sidebar() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.add('show')

    overlay.classList.add('show')

}

function hide_canvas() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.remove('show')

    overlay.classList.remove('show')

}



    </script>



    <div class="off-canvas-content">

        <div class="columns">

            <div class="column col-12 col-lg-12">

                <div class="book-navbar">

                    <!-- For Responsive Layout -->

                    <header class="navbar">

                        <section class="navbar-section">

                            <a onclick="open_sidebar()">

                                <i class="icon icon-menu"></i>

                            </a>

                        </section>

                    </header>

                </div>

                <div class="book-content" style="max-width: 960px; margin: 0 auto;

    overflow-x: auto;

    overflow-y: hidden;">

                    <div class="book-post">

                        <p id="tip" align="center"></p>

                        <div><h1>32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海</h1>

<p>当今的时代，容器的使用越来越普及，Cgroups、Docker、Kubernetes 等项目和技术越来越成熟，成为很多大规模集群的基石。</p>

<p>容器是一种沙盒技术，可以对资源进行调度分配和限制配额、对不同应用进行环境隔离。</p>

<p>容器时代不仅给我们带来的机遇，也带来了很多挑战。跨得过去就是机会，跳不过去就是坑。</p>

<p>在容器环境下，要直接进行调试并不容易，我们更多地是进行应用性能指标的采集和监控，并构建预警机制。而这需要架构师、开发、测试、运维人员的协作。</p>

<p>但监控领域的工具又多又杂，而且在持续发展和不断迭代。最早期的监控，只在系统发布时检查服务器相关的参数，并将这些参数用作系统运行状况的指标。监控服务器的健康状况，与用户体验之间紧密相关，悲剧在于监控的不完善，导致发生的问题比实际检测到的要多很多。</p>

<p>随着时间推移，日志管理、预警、遥测以及系统报告领域持续发力。其中有很多有效的措施，诸如安全事件、有效警报、记录资源使用量等等。但前提是我们需要有一个清晰的策略和对应工具，进行用户访问链路跟踪，比如 Zabbix、Nagios 以及 Prometheus 等工具在生产环境中被广泛使用。</p>

<p>性能问题的关键是人，也就是我们的用户。但已有的这些工具并没有实现真正的用户体验监控。仅仅使用这些软件也不能缓解性能问题，我们还需要采取各种措施，在勇敢和专注下不懈地努力。</p>

<p>一方面，Web 系统的问题诊断和性能调优，是一件意义重大的事情。需要严格把控，也需要付出很多精力。</p>

<p>当然，成功实施这些工作对企业的回报也是巨大的！</p>

<p>另一方面，拿 Java 领域事实上的标准 Spring 来说，SpringBoot 提供了一款应用指标收集器——Micrometer，官方文档连接：<a href="https://micrometer.io/docs">https://micrometer.io/docs</a>。</p>

<ul>

<li>支持直接将数据上报给 Elasticsearch、Datadog、InfluxData 等各种流行的监控系统。</li>

<li>自动采集最大延迟、平均延迟、95% 线、吞吐量、内存使用量等指标。</li>

</ul>

<p>此外，在小规模集群中，我们还可以使用 Pinpoint、Skywalking 等开源 APM 工具。</p>

<h3>容器环境的资源隔离性</h3>

<p>容器毕竟是一种轻量级的实现方式，所以其封闭性不如虚拟机技术。</p>

<p>举个例子：</p>

<blockquote>

<p>物理机/宿主机有 96 个 CPU 内核、256GB 物理内存，容器限制的资源是 4 核 8G，那么容器内部的 JVM 进程看到的内核数和内存数是多少呢？</p>

<p>目前来说，JVM 看到的内核数是 96，内存值是 256G。</p>

</blockquote>

<p>这会造成一些问题，基于 CPU 内核数 availableProcessors 的各种算法都会受到影响，比如默认 GC 线程数：假如啥都不配置，JVM 看见 96 个内核，设置 GC 并行线程数为 <code>96*5/8~=60</code>，但容器限制了只能使用 4 个内核资源，于是 60 个并行 GC 线程来争抢 4 个机器内核，造成严重的 GC 性能问题。</p>

<p>同样的道理，很多线程池的实现，根据内核数量来设置并发线程数，也会造成剧烈的资源争抢。如果容器不限制资源的使用也会造成一些困扰，比如下面介绍的坏邻居效应。基于物理内存 totalPhysicalMemorySize 和空闲内存 freePhysicalMemorySize 等配置信息的算法也会产生一些奇怪的 Bug。</p>

<p>最新版的 JDK 加入了一些修正手段。</p>

<h3>JDK 对容器的支持和限制</h3>

<p>新版 JDK 支持 Docker 容器的 CPU 和内存限制：</p>

<blockquote>

<p><a href="https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits">https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits</a></p>

</blockquote>

<p>可以增加 JVM 启动参数来读取 Cgroups 对 CPU 的限制：</p>

<blockquote>

<p><a href="https://www.oracle.com/technetwork/java/javase/8u191-relnotes-5032181.html#JDK-8146115">https://www.oracle.com/technetwork/java/javase/8u191-relnotes-5032181.html#JDK-8146115</a></p>

</blockquote>

<p>Hotspot 是一个规范的开源项目，关于 JDK 的新特性，可以阅读官方的邮件订阅，例如：</p>

<blockquote>

<p><a href="https://mail.openjdk.java.net/pipermail/jdk8u-dev/">https://mail.openjdk.java.net/pipermail/jdk8u-dev/</a></p>

</blockquote>

<p>其他版本的 JDK 特性，也可以按照类似的命名规范，从官网的 Mailing Lists 中找到：</p>

<blockquote>

<p><a href="https://mail.openjdk.java.net/mailman/listinfo">https://mail.openjdk.java.net/mailman/listinfo</a></p>

</blockquote>

<p>关于这个问题的排查和分析，请参考前面的章节[《JVM 问题排查分析调优经验》]。</p>

<h3>坏邻居效应</h3>

<p>有共享资源的地方，就会有资源争用。在计算机领域，共享的资源主要包括：</p>

<ul>

<li>网络</li>

<li>磁盘</li>

<li>CPU</li>

<li>内存</li>

</ul>

<p>在多租户的公有云环境中，会存在一种严重的问题，称为“坏邻居效应”（noisy neighbor phenomenon）。当一个或多个客户过度使用了某种公共资源时，就会明显损害到其他客户的系统性能。（就像是小区宽带一样）</p>

<p>吵闹的坏邻居（noisy neighbor），用于描述云计算领域中，用来描述抢占共有带宽，磁盘 I/O、CPU 以及其他资源的行为。</p>

<p>坏邻居效应，对同一环境下的其他虚拟机/应用的性能会造成影响或抖动。一般来说，会对其他用户的性能和体验造成恶劣的影响。</p>

<p>云，是一种多租户环境，同一台物理机，会共享给多个客户来运行程序/存储数据。</p>

<p>坏邻居效应产生的原因，是某个虚拟机/应用霸占了大部分资源，进而影响到其他客户的性能。</p>

<p>带宽不足是造成网络性能问题的主要原因。在网络中传输数据严重依赖带宽的大小，如果某个应用或实例占用太多的网络资源，很可能对其他用户造成延迟/缓慢。坏邻居会影响虚拟机、数据库、网络、存储以及其他云服务。</p>

<p>有一种避免坏邻居效应的方法，是使用裸机云（bare-metal cloud）。裸机云在硬件上直接运行一个应用，相当于创建了一个单租户环境，所以能消除坏邻居。虽然单租户环境避免了坏邻居效应，但并没有解决根本问题。超卖（over-commitment）或者共享给太多的租户，都会限制整个云环境的性能。</p>

<p>另一种避免坏邻居效应的方法，是通过在物理机之间进行动态迁移，以保障每个客户获得必要的资源。此外，还可以通过 存储服务质量保障（QoS，quality of service）控制每个虚拟机的 IOPS，来限制坏邻居效应。通过 IOPS 来限制每个虚拟机使用的资源量，就不会造成某个客户的虚机/应用/实例去挤占其他客户的资源/性能。</p>

<p>有兴趣的同学可以查看：</p>

<blockquote>

<p>[谈谈公有云的坏邻居效应](https://github.com/cncounter/translation/blob/master/tiemao_2016/45_noisy_neighbors/noisy_neighbor_cloud _performance.md)</p>

</blockquote>

<h3>GC 日志监听</h3>

<p>从 JDK 7 开始，每一款垃圾收集器都提供了通知机制，在程序中监听 GarbageCollectorMXBean，即可在垃圾收集完成后收到 GC 事件的详细信息。目前的监听机制只能得到 GC 完成之后的 Pause 数据，其它环节的 GC 情况无法观察到。</p>

<p>一个简单的监听程序实现如下：</p>

<pre><code class="language-java">import com.alibaba.fastjson.JSON;

import com.alibaba.fastjson.JSONObject;

import com.sun.management.GarbageCollectionNotificationInfo;

import com.sun.management.GcInfo;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import org.springframework.context.annotation.Configuration;



import javax.annotation.PostConstruct;

import javax.annotation.PreDestroy;

import javax.management.ListenerNotFoundException;

import javax.management.Notification;

import javax.management.NotificationEmitter;

import javax.management.NotificationListener;

import javax.management.openmbean.CompositeData;

import java.lang.management.*;

import java.util.*;

import java.util.concurrent.CopyOnWriteArrayList;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.atomic.AtomicLong;



/**

 * GC 日志监听并输出到 Log

 * JVM 启动参数示例:

 * -Xmx4g -Xms4g -XX:+UseG1GC -XX:MaxGCPauseMillis=50

 * -Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps

 */

@Configuration

public class BindGCNotifyConfig {



    public BindGCNotifyConfig() {

    }



    //

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    private final AtomicBoolean inited = new AtomicBoolean(Boolean.FALSE);

    private final List&lt;Runnable&gt; notifyCleanTasks = new CopyOnWriteArrayList&lt;Runnable&gt;();

    private final AtomicLong maxPauseMillis = new AtomicLong(0L);

    private final AtomicLong maxOldSize = new AtomicLong(getOldGen().getUsage().getMax());

    private final AtomicLong youngGenSizeAfter = new AtomicLong(0L);



    @PostConstruct

    public void init() {

        try {

            doInit();

        } catch (Throwable e) {

            logger.warn(&quot;[GC 日志监听-初始化]失败! &quot;, e);

        }

    }



    @PreDestroy

    public void close() {

        for (Runnable task : notifyCleanTasks) {

            task.run();

        }

        notifyCleanTasks.clear();

    }



    private void doInit() {

        //

        if (!inited.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {

            return;

        }

        logger.info(&quot;[GC 日志监听-初始化]maxOldSize=&quot; + mb(maxOldSize.longValue()));



        // 每个 mbean 都注册监听

        for (GarbageCollectorMXBean mbean : ManagementFactory.getGarbageCollectorMXBeans()) {

            if (!(mbean instanceof NotificationEmitter)) {

                continue;

            }

            final NotificationEmitter notificationEmitter = (NotificationEmitter) mbean;

            // 添加监听

            final NotificationListener notificationListener = getNewListener(mbean);

            notificationEmitter.addNotificationListener(notificationListener, null, null);



            logger.info(&quot;[GC 日志监听-初始化]MemoryPoolNames=&quot; + JSON.toJSONString(mbean.getMemoryPoolNames()));

            // 加入清理队列

            notifyCleanTasks.add(new Runnable() {

                @Override

                public void run() {

                    try {

                        // 清理掉绑定的 listener

                        notificationEmitter.removeNotificationListener(notificationListener);

                    } catch (ListenerNotFoundException e) {

                        logger.error(&quot;[GC 日志监听-清理]清理绑定的 listener 失败&quot;, e);

                    }

                }

            });

        }

    }



    private NotificationListener getNewListener(final GarbageCollectorMXBean mbean) {

        //

        final NotificationListener listener = new NotificationListener() {

            @Override

            public void handleNotification(Notification notification, Object ref) {

                // 只处理 GC 事件

                if (!notification.getType().equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) {

                    return;

                }

                CompositeData cd = (CompositeData) notification.getUserData();

                GarbageCollectionNotificationInfo notificationInfo = GarbageCollectionNotificationInfo.from(cd);

                //

                JSONObject gcDetail = new JSONObject();



                String gcName = notificationInfo.getGcName();

                String gcAction = notificationInfo.getGcAction();

                String gcCause = notificationInfo.getGcCause();

                GcInfo gcInfo = notificationInfo.getGcInfo();

                // duration 是指 Pause 阶段的总停顿时间，并发阶段没有 pause 不会通知。

                long duration = gcInfo.getDuration();

                if (maxPauseMillis.longValue() &lt; duration) {

                    maxPauseMillis.set(duration);

                }

                long gcId = gcInfo.getId();

                //

                String type = &quot;jvm.gc.pause&quot;;

                //

                if (isConcurrentPhase(gcCause)) {

                    type = &quot;jvm.gc.concurrent.phase.time&quot;;

                }

                //

                gcDetail.put(&quot;gcName&quot;, gcName);

                gcDetail.put(&quot;gcAction&quot;, gcAction);

                gcDetail.put(&quot;gcCause&quot;, gcCause);

                gcDetail.put(&quot;gcId&quot;, gcId);

                gcDetail.put(&quot;duration&quot;, duration);

                gcDetail.put(&quot;maxPauseMillis&quot;, maxPauseMillis);

                gcDetail.put(&quot;type&quot;, type);

                gcDetail.put(&quot;collectionCount&quot;, mbean.getCollectionCount());

                gcDetail.put(&quot;collectionTime&quot;, mbean.getCollectionTime());



                // 存活数据量

                AtomicLong liveDataSize = new AtomicLong(0L);

                // 提升数据量

                AtomicLong promotedBytes = new AtomicLong(0L);



                // Update promotion and allocation counters

                final Map&lt;String, MemoryUsage&gt; before = gcInfo.getMemoryUsageBeforeGc();

                final Map&lt;String, MemoryUsage&gt; after = gcInfo.getMemoryUsageAfterGc();

                //

                Set&lt;String&gt; keySet = new HashSet&lt;String&gt;();

                keySet.addAll(before.keySet());

                keySet.addAll(after.keySet());

                //

                final Map&lt;String, String&gt; afterUsage = new HashMap&lt;String, String&gt;();

                //

                for (String key : keySet) {

                    final long usedBefore = before.get(key).getUsed();

                    final long usedAfter = after.get(key).getUsed();

                    long delta = usedAfter - usedBefore;

                    // 判断是 yong 还是 old，算法不同

                    if (isYoungGenPool(key)) {

                        delta = usedBefore - youngGenSizeAfter.get();

                        youngGenSizeAfter.set(usedAfter);

                    } else if (isOldGenPool(key)) {

                        if (delta &gt; 0L) {

                            // 提升到老年代的量

                            promotedBytes.addAndGet(delta);

                            gcDetail.put(&quot;promotedBytes&quot;, mb(promotedBytes));

                        }

                        if (delta &lt; 0L || GcGenerationAge.OLD.contains(gcName)) {

                            liveDataSize.set(usedAfter);

                            gcDetail.put(&quot;liveDataSize&quot;, mb(liveDataSize));

                            final long oldMaxAfter = after.get(key).getMax();

                            if (maxOldSize.longValue() != oldMaxAfter) {

                                maxOldSize.set(oldMaxAfter);

                                // 扩容；老年代的 max 有变更

                                gcDetail.put(&quot;maxOldSize&quot;, mb(maxOldSize));

                            }

                        }

                    } else if (delta &gt; 0L) {

                        //

                    } else if (delta &lt; 0L) {

                        // 判断 G1

                    }

                    afterUsage.put(key, mb(usedAfter));

                }

                //

                gcDetail.put(&quot;afterUsage&quot;, afterUsage);

                //



                logger.info(&quot;[GC 日志监听-GC 事件]gcId={}; duration:{}; gcDetail: {}&quot;, gcId, duration, gcDetail.toJSONString());

            }

        };



        return listener;

    }



    private static String mb(Number num) {

        long mbValue = num.longValue() / (1024 * 1024);

        if (mbValue &lt; 1) {

            return &quot;&quot; + mbValue;

        }

        return mbValue + &quot;MB&quot;;

    }



    private static MemoryPoolMXBean getOldGen() {

        List&lt;MemoryPoolMXBean&gt; list = ManagementFactory

                .getPlatformMXBeans(MemoryPoolMXBean.class);

        //

        for (MemoryPoolMXBean memoryPoolMXBean : list) {

            // 非堆的部分-不是老年代

            if (!isHeap(memoryPoolMXBean)) {

                continue;

            }

            if (!isOldGenPool(memoryPoolMXBean.getName())) {

                continue;

            }

            return (memoryPoolMXBean);

        }

        return null;

    }



    private static boolean isConcurrentPhase(String cause) {

        return &quot;No GC&quot;.equals(cause);

    }



    private static boolean isYoungGenPool(String name) {

        return name.endsWith(&quot;Eden Space&quot;);

    }



    private static boolean isOldGenPool(String name) {

        return name.endsWith(&quot;Old Gen&quot;) || name.endsWith(&quot;Tenured Gen&quot;);

    }



    private static boolean isHeap(MemoryPoolMXBean memoryPoolBean) {

        return MemoryType.HEAP.equals(memoryPoolBean.getType());

    }



    private enum GcGenerationAge {

        OLD,

        YOUNG,

        UNKNOWN;



        private static Map&lt;String, GcGenerationAge&gt; knownCollectors = new HashMap&lt;String, BindGCNotifyConfig.GcGenerationAge&gt;() {{

            put(&quot;ConcurrentMarkSweep&quot;, OLD);

            put(&quot;Copy&quot;, YOUNG);

            put(&quot;G1 Old Generation&quot;, OLD);

            put(&quot;G1 Young Generation&quot;, YOUNG);

            put(&quot;MarkSweepCompact&quot;, OLD);

            put(&quot;PS MarkSweep&quot;, OLD);

            put(&quot;PS Scavenge&quot;, YOUNG);

            put(&quot;ParNew&quot;, YOUNG);

        }};



        static GcGenerationAge fromName(String name) {

            return knownCollectors.getOrDefault(name, UNKNOWN);

        }



        public boolean contains(String name) {

            return this == fromName(name);

        }

    }



}



</code></pre>

<p>不只是 GC 事件，内存相关的信息都可以通过 JMX 来实现监听。很多 APM 也是通过类似的手段来实现数据上报。</p>

<h3>APM 工具与监控系统</h3>

<p>在线可视化监控是如今生产环境必备的一个功能。业务出错和性能问题随时都可能会发生，而且现在很多系统不再有固定的业务窗口期，所以必须做到 7x24 小时的实时监控。</p>

<p>目前业界有很多监控工具，各有优缺点，需要根据需要进行抉择。</p>

<p>一般来说，系统监控可以分为三个部分：</p>

<ul>

<li>系统性能监控，包括 CPU、内存、磁盘 IO、网络等硬件资源和系统负载的监控信息。</li>

<li>业务日志监控，场景的是 ELK 技术栈、并使用 Logback+Kafka 等技术来采集日志。</li>

<li>APM 性能指标监控，比如 QPS、TPS、响应时间等等，例如 MicroMeter、Pinpoint 等。</li>

</ul>

<p>系统监控的模块也是两大块：</p>

<ul>

<li>指标采集部分</li>

<li>数据可视化系统</li>

</ul>

<p>如今监控工具是生产环境的重要组成部分。测量结果的可视化、错误追踪、性能监控和应用分析是对应用的运行状况进行深入观测的基本手段。</p>

<p>认识到这一需求非常容易，但要选择哪一款监控工具或者哪一组监控工具却异常困难。</p>

<p>下面介绍几款监测工具，这些工具包括混合开源和 SaaS 模式，每个都有其优缺点，可以说没有完美的工具，只有合适的工具。</p>

<h4><strong>指标采集客户端</strong></h4>

<ul>

<li>Micrometer：作为指标采集的基础类库，基于客户端机器来进行，用户无需关注具体的 JVM 版本和厂商。以相同的方式来配置，可以对接到不同的可视化监控系统服务。主要用于监控、告警，以及对当前的系统环境变化做出响应。Micrometer 还会注册 JMX 相关的 MBeans，非常简单和方便地在本地通过 JMX 来查看相关指标。如果是生产环境中使用，则一般是将监控指标导出到其他监控系统中保存起来。</li>

<li>云服务监控系统：云服务监控系统厂商一般都会提供配套的指标采集客户端，并对外开放各种 API 接口和数据标准，允许客户使用自己的指标采集系统。</li>

<li>开源监控系统：各种开源监控系统也会提供对应的指标采集客户端。</li>

</ul>

<h4><strong>云服务监控系统</strong></h4>

<p>SaaS 服务的监控系统一般提供存储、查询、可视化等功能的一体化云服务。大多包含免费试用和收费服务两种模式。如果企业和机构的条件允许，付费使用云服务一般是最好的选择，毕竟“免费的才是最贵的”。</p>

<p>下面我们一起来看看有哪些云服务：</p>

<ul>

<li><a href="https://www.appoptics.com/">AppOptics</a>，支持 APM 和系统监控的 SaaS 服务，支持各种仪表板和时间轴等监控界面，提供 API 和客户端。</li>

<li><a href="https://www.datadoghq.com/">Datadog</a>，支持 APM 和系统监控的 SaaS 服务，内置各种仪表板，支持告警。支持 API 和客户端，以及客户端代理。</li>

<li><a href="https://www.dynatrace.com/">Dynatrace</a>，支持 APM 和系统监控的 SaaS 服务，内置各种仪表板，集成了监控和分析平台。</li>

<li><a href="https://www.humio.com/">Humio</a>，支持 APM、日志和系统监控的 SaaS 服务。</li>

<li><a href="https://www.instana.com/">Instana</a>，支持自动 APM、系统监控的 SaaS 服务。</li>

<li><a href="https://newrelic.com/">New Relic</a>，这是一款具有完整 UI 的可视化 SaaS 产品，支持 NRQL 查询语言，New Relic Insights 基于推模型来运行。</li>

<li><a href="https://www.signalfx.com/">SignalFx</a>，在推送模型上运行的 SaaS 服务，具有完整 UI。支持实时的系统性能、微服务，以及 APM 监控系统，支持多样化的预警“检测器”。</li>

<li><a href="https://cloud.google.com/stackdriver?hl=zh-cn">Stackdriver</a>，是 Google Cloud 的嵌入式监测套件，用于监控云基础架构、软件和应用的性能，排查其中的问题并加以改善。这个监测套件属于 SaaS 服务，支持内置仪表板和告警功能。</li>

<li><a href="https://www.wavefront.com/">Wavefront</a>，是基于 SaaS 的指标监视和分析平台，支持可视化查询，以及预警监控等功能，包括系统性能、网络、自定义指标、业务 KPI 等等。</li>

<li><a href="https://www.tingyun.com/">听云</a>，是国内最大的应用性能管理（APM）解决方案提供商。可以实现应用性能全方位可视化，从 PC 端、浏览器端、移动客户端到服务端，监控定位崩溃、卡顿、交互过慢、第三方 API 调用失败、数据库性能下降、CDN 质量差等多维复杂的性能问题。</li>

<li><a href="https://www.oneapm.com/index.html">OneAPM</a>，OneAPM（蓝海讯通）提供端到端 APM 应用性能管理软件及应用性能监控软件解决方案。</li>

<li><a href="https://plumbr.io/">Plumbr</a>，监测可用性和性能问题，使用跟踪技术，能迅速定位错误相关的位置信息，发现、验证和修复各种故障和性能问题。</li>

<li><a href="https://www.overops.com/">Takipi</a>，现在改名叫做 OverOps，系统故障实时监测系统。能快速定位问题发生的时间、位置和原因。</li>

</ul>

<p>其中做得比较好的有国外的 Datadog，国内的听云。</p>

<h4><strong>开源监控系统</strong></h4>

<ul>

<li><a href="https://github.com/naver/pinpoint">Pinpoint</a>，受 Dapper 启发，使用 Java/PHP 来实现的大型分布式系统 APM 工具。Pinpoint 提供了一套解决方案，可通过跟踪分布式应用程序之间的事务来快速定位调用链路。</li>

<li><a href="https://github.com/Netflix/atlas">Atlas</a>，是 Netflix 旗下的一款开源的，基于内存的时序数据库，内置图形界面，支持高级数学运算和自定义查询语言。</li>

<li><a href="https://www.elastic.co/">ELK 技术栈</a>，一般用于日志监控，<a href="https://www.elastic.co/">Elasticsearch</a> 是搜索引擎，支持各种数据和指标存储，日志监控一般通过 <a href="https://www.elastic.co/products/logstash">Logstash</a> 执行分析，<a href="https://www.elastic.co/products/kibana">Kibana</a> 负责人机交互和可视化。</li>

<li><a href="https://www.influxdata.com/">Influx</a>，InfluxDB 是由 InfluxData 开发的一款开源时序型数据库。它由 Go 写成，着力于高性能地查询与存储时序数据。InfluxDB 被广泛应用于存储系统的监控数据、IoT 行业的实时数据等场景，通过类似 SQL 的查询语言来完成数据分析。InfluxData 工具套件可用于实时流处理，支持抽样采集指标、自动过期、删除不需要的数据，以及备份和还原等功能。</li>

<li><a href="http://ganglia.sourceforge.net/">Ganglia</a>，用于高性能计算系统、群集和网络的可伸缩的分布式监控工具。起源于加州大学伯克利分校，是一款历史悠久的多层级指标监控系统，在 Linux 系统中广受欢迎。</li>

<li><a href="https://graphiteapp.org/">Graphite</a>，当前非常流行的多层级次指标监控系统，使用固定数量的底层数据库，其设计和目的与 RRD 相似。由 Orbitz 在 2006 年创建，并于 2008 年开源。</li>

<li><a href="https://kairosdb.github.io/">KairosDB</a>，是建立在 <a href="https://cassandra.apache.org/">Apache Cassandra</a> 基础上的时序数据库。可以通过 <a href="https://grafana.com/">Grafana</a> 来绘制精美漂亮的监控图表。</li>

<li><a href="https://prometheus.io/">Prometheus</a>，具有简单的内置 UI，支持自定义查询语言和数学运算的、开源的内存时序数据库。Prometheus 设计为基于拉模型来运行，根据服务发现，定期从应用程序实例中收集指标。</li>

<li><a href="https://github.com/statsd/statsd">StatsD</a>，开源的、简单但很强大的统计信息聚合服务器。</li>

</ul>

<p>其中 Pinpoint 和 Prometheus 比较受欢迎。</p>

<h3>参考链接</h3>

<ul>

<li><a href="http://blog.lichengwu.cn/java/2013/09/15/listen-gc-using-jmx-notification/">利用 JMX 的 Notifications 监听 GC</a></li>

<li><a href="https://www.oschina.net/translate/7-monitoring-tools-to-prevent-the-next-doomsday">推荐 7 个超棒的监控工具</a></li>

</ul>

</div>

                    </div>

                    <div>

                        <div style="float: left">

                            <a href="/专栏/JVM 核心技术 32 讲（完）/31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md.html">上一页</a>

                        </div>

                        

                    </div>



                </div>

            </div>

        </div>

    </div>



    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

</div>

<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"7099700b4b703d60","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>

</body>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script>

    window.dataLayer = window.dataLayer || [];



    function gtag() {

        dataLayer.push(arguments);

    }



    gtag('js', new Date());

    gtag('config', 'G-NPSEEVD756');

    var path = window.location.pathname

    var cookie = getCookie("lastPath");

    console.log(path)

    if (path.replace("/", "") === "") {

        if (cookie.replace("/", "") !== "") {

            console.log(cookie)

            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"

        }

    } else {

        setCookie("lastPath", path)

    }



    function setCookie(cname, cvalue) {

        var d = new Date();

        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));

        var expires = "expires=" + d.toGMTString();

        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";

    }



    function getCookie(cname) {

        var name = cname + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i].trim();

            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);

        }

        return "";

    }



</script>



</html>

